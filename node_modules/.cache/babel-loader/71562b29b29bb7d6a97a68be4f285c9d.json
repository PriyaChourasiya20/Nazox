{"ast":null,"code":"'use strict';\n\nvar hasOwn = require('hasown');\n\nvar VALIDATE = require('./validate');\n\nmodule.exports = function (REGION) {\n  var MAX = Math.max;\n  var MIN = Math.min;\n  var statics = {\n    init: function () {\n      var exportAsNonStatic = {\n        getIntersection: true,\n        getIntersectionArea: true,\n        getIntersectionHeight: true,\n        getIntersectionWidth: true,\n        getUnion: true\n      };\n      var thisProto = REGION.prototype;\n      var newName;\n      var exportHasOwn = hasOwn(exportAsNonStatic);\n      var methodName;\n\n      for (methodName in exportAsNonStatic) if (exportHasOwn(methodName)) {\n        newName = exportAsNonStatic[methodName];\n\n        if (typeof newName != 'string') {\n          newName = methodName;\n        }\n\n        ;\n\n        (function (proto, methodName, protoMethodName) {\n          proto[methodName] = function (region) {\n            //<debug>\n            if (!REGION[protoMethodName]) {\n              console.warn('cannot find method ', protoMethodName, ' on ', REGION);\n            } //</debug>\n\n\n            return REGION[protoMethodName](this, region);\n          };\n        })(thisProto, newName, methodName);\n      }\n    },\n    validate: VALIDATE,\n\n    /**\n     * Returns the region corresponding to the documentElement\n     * @return {Region} The region corresponding to the documentElement. This region is the maximum region visible on the screen.\n     */\n    getDocRegion: function () {\n      return REGION.fromDOM(document.documentElement);\n    },\n    from: function (reg) {\n      if (reg.__IS_REGION) {\n        return reg;\n      }\n\n      if (typeof document != 'undefined') {\n        if (typeof HTMLElement != 'undefined' && reg instanceof HTMLElement) {\n          return REGION.fromDOM(reg);\n        }\n\n        if (reg.type && typeof reg.pageX !== 'undefined' && typeof reg.pageY !== 'undefined') {\n          return REGION.fromEvent(reg);\n        }\n      }\n\n      return REGION(reg);\n    },\n    fromEvent: function (event) {\n      return REGION.fromPoint({\n        x: event.pageX,\n        y: event.pageY\n      });\n    },\n    fromDOM: function (dom) {\n      var rect = dom.getBoundingClientRect(); // var docElem = document.documentElement\n      // var win     = window\n      // var top  = rect.top + win.pageYOffset - docElem.clientTop\n      // var left = rect.left + win.pageXOffset - docElem.clientLeft\n\n      return new REGION({\n        top: rect.top,\n        left: rect.left,\n        bottom: rect.bottom,\n        right: rect.right\n      });\n    },\n\n    /**\n     * @static\n     * Returns a region that is the intersection of the given two regions\n     * @param  {Region} first  The first region\n     * @param  {Region} second The second region\n     * @return {Region/Boolean}        The intersection region or false if no intersection found\n     */\n    getIntersection: function (first, second) {\n      var area = this.getIntersectionArea(first, second);\n\n      if (area) {\n        return new REGION(area);\n      }\n\n      return false;\n    },\n    getIntersectionWidth: function (first, second) {\n      var minRight = MIN(first.right, second.right);\n      var maxLeft = MAX(first.left, second.left);\n\n      if (maxLeft < minRight) {\n        return minRight - maxLeft;\n      }\n\n      return 0;\n    },\n    getIntersectionHeight: function (first, second) {\n      var maxTop = MAX(first.top, second.top);\n      var minBottom = MIN(first.bottom, second.bottom);\n\n      if (maxTop < minBottom) {\n        return minBottom - maxTop;\n      }\n\n      return 0;\n    },\n    getIntersectionArea: function (first, second) {\n      var maxTop = MAX(first.top, second.top);\n      var minRight = MIN(first.right, second.right);\n      var minBottom = MIN(first.bottom, second.bottom);\n      var maxLeft = MAX(first.left, second.left);\n\n      if (maxTop < minBottom && maxLeft < minRight) {\n        return {\n          top: maxTop,\n          right: minRight,\n          bottom: minBottom,\n          left: maxLeft,\n          width: minRight - maxLeft,\n          height: minBottom - maxTop\n        };\n      }\n\n      return false;\n    },\n\n    /**\n     * @static\n     * Returns a region that is the union of the given two regions\n     * @param  {Region} first  The first region\n     * @param  {Region} second The second region\n     * @return {Region}        The union region. The smallest region that contains both given regions.\n     */\n    getUnion: function (first, second) {\n      var top = MIN(first.top, second.top);\n      var right = MAX(first.right, second.right);\n      var bottom = MAX(first.bottom, second.bottom);\n      var left = MIN(first.left, second.left);\n      return new REGION(top, right, bottom, left);\n    },\n\n    /**\n     * @static\n     * Returns a region. If the reg argument is a region, returns it, otherwise return a new region built from the reg object.\n     *\n     * @param  {Region} reg A region or an object with either top, left, bottom, right or\n     * with top, left, width, height\n     * @return {Region} A region\n     */\n    getRegion: function (reg) {\n      return REGION.from(reg);\n    },\n\n    /**\n     * Creates a region that corresponds to a point.\n     *\n     * @param  {Object} xy The point\n     * @param  {Number} xy.x\n     * @param  {Number} xy.y\n     *\n     * @return {Region}    The new region, with top==xy.y, bottom = xy.y and left==xy.x, right==xy.x\n     */\n    fromPoint: function (xy) {\n      return new REGION({\n        top: xy.y,\n        bottom: xy.y,\n        left: xy.x,\n        right: xy.x\n      });\n    }\n  };\n  Object.keys(statics).forEach(function (key) {\n    REGION[key] = statics[key];\n  });\n  REGION.init();\n};","map":{"version":3,"names":["hasOwn","require","VALIDATE","module","exports","REGION","MAX","Math","max","MIN","min","statics","init","exportAsNonStatic","getIntersection","getIntersectionArea","getIntersectionHeight","getIntersectionWidth","getUnion","thisProto","prototype","newName","exportHasOwn","methodName","proto","protoMethodName","region","console","warn","validate","getDocRegion","fromDOM","document","documentElement","from","reg","__IS_REGION","HTMLElement","type","pageX","pageY","fromEvent","event","fromPoint","x","y","dom","rect","getBoundingClientRect","top","left","bottom","right","first","second","area","minRight","maxLeft","maxTop","minBottom","width","height","getRegion","xy","Object","keys","forEach","key"],"sources":["/home/rovi91/Downloads/copy (new)/node_modules/region/src/statics.js"],"sourcesContent":["'use strict';\n\nvar hasOwn   = require('hasown')\nvar VALIDATE = require('./validate')\n\nmodule.exports = function(REGION){\n\n    var MAX = Math.max\n    var MIN = Math.min\n\n    var statics = {\n        init: function(){\n            var exportAsNonStatic = {\n                getIntersection      : true,\n                getIntersectionArea  : true,\n                getIntersectionHeight: true,\n                getIntersectionWidth : true,\n                getUnion             : true\n            }\n            var thisProto = REGION.prototype\n            var newName\n\n            var exportHasOwn = hasOwn(exportAsNonStatic)\n            var methodName\n\n            for (methodName in exportAsNonStatic) if (exportHasOwn(methodName)) {\n                newName = exportAsNonStatic[methodName]\n                if (typeof newName != 'string'){\n                    newName = methodName\n                }\n\n                ;(function(proto, methodName, protoMethodName){\n\n                    proto[methodName] = function(region){\n                        //<debug>\n                        if (!REGION[protoMethodName]){\n                            console.warn('cannot find method ', protoMethodName,' on ', REGION)\n                        }\n                        //</debug>\n                        return REGION[protoMethodName](this, region)\n                    }\n\n                })(thisProto, newName, methodName);\n            }\n        },\n\n        validate: VALIDATE,\n\n        /**\n         * Returns the region corresponding to the documentElement\n         * @return {Region} The region corresponding to the documentElement. This region is the maximum region visible on the screen.\n         */\n        getDocRegion: function(){\n            return REGION.fromDOM(document.documentElement)\n        },\n\n        from: function(reg){\n            if (reg.__IS_REGION){\n                return reg\n            }\n\n            if (typeof document != 'undefined'){\n                if (typeof HTMLElement != 'undefined' && reg instanceof HTMLElement){\n                    return REGION.fromDOM(reg)\n                }\n\n                if (reg.type && typeof reg.pageX !== 'undefined' && typeof reg.pageY !== 'undefined'){\n                    return REGION.fromEvent(reg)\n                }\n            }\n\n            return REGION(reg)\n        },\n\n        fromEvent: function(event){\n            return REGION.fromPoint({\n                x: event.pageX,\n                y: event.pageY\n            })\n        },\n\n        fromDOM: function(dom){\n            var rect = dom.getBoundingClientRect()\n            // var docElem = document.documentElement\n            // var win     = window\n\n            // var top  = rect.top + win.pageYOffset - docElem.clientTop\n            // var left = rect.left + win.pageXOffset - docElem.clientLeft\n\n            return new REGION({\n                top   : rect.top,\n                left  : rect.left,\n                bottom: rect.bottom,\n                right : rect.right\n            })\n        },\n\n        /**\n         * @static\n         * Returns a region that is the intersection of the given two regions\n         * @param  {Region} first  The first region\n         * @param  {Region} second The second region\n         * @return {Region/Boolean}        The intersection region or false if no intersection found\n         */\n        getIntersection: function(first, second){\n\n            var area = this.getIntersectionArea(first, second)\n\n            if (area){\n                return new REGION(area)\n            }\n\n            return false\n        },\n\n        getIntersectionWidth: function(first, second){\n            var minRight  = MIN(first.right, second.right)\n            var maxLeft   = MAX(first.left,  second.left)\n\n            if (maxLeft < minRight){\n                return minRight  - maxLeft\n            }\n\n            return 0\n        },\n\n        getIntersectionHeight: function(first, second){\n            var maxTop    = MAX(first.top,   second.top)\n            var minBottom = MIN(first.bottom,second.bottom)\n\n            if (maxTop  < minBottom){\n                return minBottom - maxTop\n            }\n\n            return 0\n        },\n\n        getIntersectionArea: function(first, second){\n            var maxTop    = MAX(first.top,   second.top)\n            var minRight  = MIN(first.right, second.right)\n            var minBottom = MIN(first.bottom,second.bottom)\n            var maxLeft   = MAX(first.left,  second.left)\n\n            if (\n                    maxTop  < minBottom &&\n                    maxLeft < minRight\n                ){\n                return {\n                    top    : maxTop,\n                    right  : minRight,\n                    bottom : minBottom,\n                    left   : maxLeft,\n\n                    width  : minRight  - maxLeft,\n                    height : minBottom - maxTop\n                }\n            }\n\n            return false\n        },\n\n        /**\n         * @static\n         * Returns a region that is the union of the given two regions\n         * @param  {Region} first  The first region\n         * @param  {Region} second The second region\n         * @return {Region}        The union region. The smallest region that contains both given regions.\n         */\n        getUnion: function(first, second){\n            var top    = MIN(first.top,   second.top)\n            var right  = MAX(first.right, second.right)\n            var bottom = MAX(first.bottom,second.bottom)\n            var left   = MIN(first.left,  second.left)\n\n            return new REGION(top, right, bottom, left)\n        },\n\n        /**\n         * @static\n         * Returns a region. If the reg argument is a region, returns it, otherwise return a new region built from the reg object.\n         *\n         * @param  {Region} reg A region or an object with either top, left, bottom, right or\n         * with top, left, width, height\n         * @return {Region} A region\n         */\n        getRegion: function(reg){\n            return REGION.from(reg)\n        },\n\n        /**\n         * Creates a region that corresponds to a point.\n         *\n         * @param  {Object} xy The point\n         * @param  {Number} xy.x\n         * @param  {Number} xy.y\n         *\n         * @return {Region}    The new region, with top==xy.y, bottom = xy.y and left==xy.x, right==xy.x\n         */\n        fromPoint: function(xy){\n            return new REGION({\n                        top    : xy.y,\n                        bottom : xy.y,\n                        left   : xy.x,\n                        right  : xy.x\n                    })\n        }\n    }\n\n    Object.keys(statics).forEach(function(key){\n        REGION[key] = statics[key]\n    })\n\n    REGION.init()\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}